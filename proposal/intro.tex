% !TEX root = proposal.tex
\section{Introduction} 
\label{sec:intro}

Protecting software system is a challenging task. 
%
Attack vectors available to attackers are often unknown and this leads to
incapable of defending zero day attacks.
%
Developers make mistakes in their codes.

% Securing/positioning the document -- needs elaboration.
%
In respond to these problems, we have seen many proposals that
inject/instrument one or more type of monitoring logics~\cite{cfi, memcheck,
dft} against the program that we want to protect and let them run
simultaneously to defend against various types of unexpected behaviors.
%
Research has been exploring three different approaches to instrument/in-line
monitoring logics to implement in-line monitors.
%
Number of criteria to compare and evaluate different approaches. efficiency,
coverage, flexibility(general ?).

\begin{itemize}
%
    \item {\bf Source code based:} Leveraging different representations exposed
in the process of program build. Abstract Syntax Tree~(AST) or compiler
specific Intermediate Representations~(IR) can be an instrumentation target.
This approach is reasonably fast incurring about or less than $\sim$ 2$\times$
overhead, but it can encounter an issue related to code {\it coverage} as in
most case we only have a partial source access about program's execution
environment for having 3rd party libraries~(\ie libc) that come as binaries.
%
    \item {\bf Hardware assisted:} This approach leverages hardware add-ons to
instrument monitoring defense logics to a runtime execution and it is the most
efficient approach being able to achieve near-to-native performance. The
approach is not flexible as users cannot modify monitoring logics once it is
fixed/burned/encoded to hardware. This is also not general as we have not seen
any commodity vendors that implements this kind of in-line monitors.
%
    \item {\bf VM-based instrumentation:}  This approach leverages widely
adopted VM-hypervisor for instrumentation. As this approach overcomes the
coverage issue supporting unknown(COTS) binaries and users can freely modify
and update their monitoring logics, the approach incurs to much runtime
overhead.

\end{itemize}
%
The approach based on VM-based instrumentation, being effective in defending
software systems against aforementioned threats, is regarded as the most
promising for its ability to address limitation of other approaches -- coverage
and flexibility. 
%
However the approach suffers from excessive amount of slowdown and the sources
for the overhead are {\it i)} instrumentation cost needed to maintain two
different contexts {\it ii)} cycles for defense/monitoring logic itself.
%

The idea of parallel analysis that decouples the original application and
analysis logics and executes these contexts from different execution
units~(threads) has risen from past research to minimize the runtime overhead.  
%
We have two different approaches based on process replication and subset state
propagation.
%
The cost for the communication connecting two threads tends to be too
high/excessive for both approaches, subsequently masks/overwhelms/cancels the
parallelization benefit and often make it slower than comparable in-lined
analysis. Its side-effects include

\begin{itemize} \item n analyzer threads.  \item synchronization becomes too
difficult.  \item not suitable for online/runtime analysis. In turn, some are
purely positioned themselves as an off-line solution.  \end{itemize}

%Preliminary result -- explain ShadowReplica, TFA, libdft
From my previous research~\cite{ShadowReplica, TFA}, I proposed a system that
directly addresses the issue of too high communication overhead for an analysis
of Data Flow Tracking~(DFT). The system identifies minimal but necessary
elements from the original executions and then establishes a framework that
applies number of optimizations to properly compress the runtime communication
which eventually contributes to {\it i)} minimize the mitigation of event
collection to the original execution, {\it ii)} minimize the communication
traffic, and {\it iii)} make the analysis thread run faster than the original
thread.

%what this proposal is about.
\jikk{Hypothesis is not clear.}
%"our hypothesis is that the use of XYZ technology in environment Z under
%constraints Q can identify insider attackers with probability Z" 

From this document, I propose an approach that generalizes my previous work
that defines the minimal amount of information required from arbitrary program
execution applicable to restore wider range of in-lined monitors from another
threads.
%
For this, I provide framework for to categorize available in-line
monitors~\cite{CAB} with number of abstractions for necessary/implemented
functionalities common to these analyses which, I expect, would help us to
define common API exposed to users to implement their own parallelized
analysis.
%
Then, I investigate the general and specific optimizations applicable to each
analyses.

% Novelty, if it is properly implemented/fulfilled.
We are defining minimal but necessary amount of information required to offload
monitoring logics from the original execution. Once it is properly defined,
research as well as industry can take advantage of it to make known-to-be
expensive security measures more widely/generally adopted.
%
This would have impact on many areas hardware based implementation, mobile
security, and cloud computing.


